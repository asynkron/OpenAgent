#!/usr/bin/env node

import fs from 'node:fs/promises';
import path from 'node:path';
import process from 'node:process';

async function readStdin() {
  return new Promise((resolve, reject) => {
    const chunks = [];
    process.stdin.on('data', chunk => chunks.push(chunk));
    process.stdin.on('end', () => resolve(Buffer.concat(chunks).toString('utf8')));
    process.stdin.on('error', reject);
  });
}

function parsePatch(input) {
  const operations = [];
  const lines = input.split(/\r?\n/);
  let inside = false;
  let currentOp = null;
  let currentHunk = null;

  const flushHunk = () => {
    if (!currentHunk) return;
    const parsed = parseHunk(currentHunk.lines, currentOp.path);
    currentOp.hunks.push(parsed);
    currentHunk = null;
  };

  const flushOp = () => {
    if (!currentOp) return;
    flushHunk();
    if (currentOp.hunks.length === 0) {
      throw new Error(`No hunks provided for ${currentOp.path}`);
    }
    operations.push(currentOp);
    currentOp = null;
  };

  for (const rawLine of lines) {
    const line = rawLine;
    if (line === '*** Begin Patch') {
      inside = true;
      continue;
    }
    if (line === '*** End Patch') {
      if (inside) {
        flushOp();
      }
      inside = false;
      continue;
    }
    if (!inside) {
      continue;
    }

    if (line.startsWith('*** ')) {
      flushOp();
      const updateMatch = line.match(/^\*\*\* Update File:\s*(.+)$/);
      if (updateMatch) {
        currentOp = { type: 'update', path: updateMatch[1], hunks: [] };
        continue;
      }
      throw new Error(`Unsupported patch directive: ${line}`);
    }

    if (!currentOp) {
      if (line.trim() === '') {
        continue;
      }
      throw new Error(`Diff content appeared before a file directive: "${line}"`);
    }

    if (line.startsWith('@@')) {
      flushHunk();
      currentHunk = { lines: [] };
      continue;
    }

    if (!currentHunk) {
      currentHunk = { lines: [] };
    }
    currentHunk.lines.push(line);
  }

  if (inside) {
    throw new Error('Missing *** End Patch terminator.');
  }
  flushOp();
  return operations;
}

function parseHunk(lines, filePath) {
  const before = [];
  const after = [];
  for (const raw of lines) {
    if (raw.startsWith('+')) {
      after.push(raw.slice(1));
    } else if (raw.startsWith('-')) {
      before.push(raw.slice(1));
    } else if (raw.startsWith(' ')) {
      const value = raw.slice(1);
      before.push(value);
      after.push(value);
    } else if (raw === '\\ No newline at end of file') {
      continue;
    } else {
      throw new Error(`Unsupported hunk line in ${filePath}: "${raw}"`);
    }
  }
  return { before, after, rawLines: lines.slice() };
}

function findSubsequence(haystack, needle, startIndex = 0) {
  if (needle.length === 0) {
    return -1;
  }
  outer: for (let i = startIndex; i <= haystack.length - needle.length; i += 1) {
    for (let j = 0; j < needle.length; j += 1) {
      if (haystack[i + j] !== needle[j]) {
        continue outer;
      }
    }
    return i;
  }
  return -1;
}

function applyHunk(state, hunk) {
  const { before, after } = hunk;
  const { lines } = state;

  if (before.length === 0) {
    const endsWithEmpty = lines.length > 0 && lines[lines.length - 1] === '';
    const insertionIndex = endsWithEmpty ? lines.length - 1 : lines.length;
    lines.splice(insertionIndex, 0, ...after);
    state.cursor = insertionIndex + after.length;
    return;
  }

  let matchIndex = findSubsequence(lines, before, state.cursor);
  if (matchIndex === -1) {
    matchIndex = findSubsequence(lines, before, 0);
  }
  if (matchIndex === -1) {
    throw new Error(`Unable to locate hunk in ${state.relativePath}.`);
  }

  lines.splice(matchIndex, before.length, ...after);
  state.cursor = matchIndex + after.length;
}

async function applyOperations(operations) {
  const fileStates = new Map();

  const ensureFileState = async relativePath => {
    const absolutePath = path.resolve(relativePath);
    if (fileStates.has(absolutePath)) {
      return fileStates.get(absolutePath);
    }
    let content;
    try {
      content = await fs.readFile(absolutePath, 'utf8');
    } catch (error) {
      throw new Error(`Failed to read ${relativePath}: ${error.message}`);
    }
    const normalized = content.replace(/\r\n/g, '\n');
    const lines = normalized.split('\n');
    const state = {
      path: absolutePath,
      relativePath,
      lines,
      originalEndsWithNewline: normalized.endsWith('\n'),
      touched: false,
      cursor: 0
    };
    fileStates.set(absolutePath, state);
    return state;
  };

  for (const op of operations) {
    if (op.type !== 'update') {
      throw new Error(`Unsupported patch operation for ${op.path}: ${op.type}`);
    }
    const state = await ensureFileState(op.path);
    state.cursor = 0;
    for (const hunk of op.hunks) {
      applyHunk(state, hunk);
      state.touched = true;
    }
  }

  const results = [];
  for (const state of fileStates.values()) {
    if (!state.touched) {
      continue;
    }
    let newContent = state.lines.join('\n');
    if (state.originalEndsWithNewline && !newContent.endsWith('\n')) {
      newContent += '\n';
    } else if (!state.originalEndsWithNewline && newContent.endsWith('\n')) {
      newContent = newContent.slice(0, -1);
    }
    await fs.writeFile(state.path, newContent, 'utf8');
    results.push({ status: 'M', path: state.relativePath });
  }

  return results;
}

function exitWithError(message) {
  console.error(message);
  process.exit(1);
}

async function main() {
  const input = await readStdin();
  if (!input.trim()) {
    exitWithError('No patch provided via stdin.');
  }

  let operations;
  try {
    operations = parsePatch(input);
  } catch (error) {
    exitWithError(error.message);
  }

  if (operations.length === 0) {
    exitWithError('No patch operations detected.');
  }

  try {
    const results = await applyOperations(operations);
    if (results.length === 0) {
      console.log('No changes applied.');
      return;
    }
    const ordered = results.sort((a, b) => a.path.localeCompare(b.path));
    console.log('Success. Updated the following files:');
    for (const entry of ordered) {
      console.log(`${entry.status} ${entry.path}`);
    }
  } catch (error) {
    exitWithError(error.message);
  }
}

main().catch(error => exitWithError(error.message));
